% ******************************************************************************%
%                                                                               % 
%         RFC_FancyCron.tex for FancyCron Project specification                 %
%            Made by: Eugène NGONTANG <ngonta_e@epitech.net>                    %
%                    engontan@bouyguestelecom.fr                                %
%                                                                               % 
% ******************************************************************************%

\documentclass{bouygues-fr}
%%\usepackage{sidecap}
\usepackage{supertabular}
\usepackage{longtable}

% ******************************************************************************%
%                                                                               % 
%                                 Prologue                                      %
%                                                                               % 
% ******************************************************************************%

\begin{document}



\title{\texttt{FancyCron}}
\subtitle{Protocole Version 1.0}

\member{Eugène NGONTANG}{ngonta_e@epitech.net}
\member{DSI/DOQS/PFI Bougues Telecom}{engontan@bouyguestelecom.fr}

%%\newpage

\summary
{
  Ce document decrit le protocole de communication FancyCron.  Il a pour but de spécifier les échanges d'informations entre un client et un serveur FancyCron, au niveau applicatif.
  
  Il définit également le protocole de couche transport utilisé pour ces échanges.
}

\maketitle

\tableofcontents

\renewcommand{\labelitemi}{$\bullet$}
\renewcommand{\labelitemii}{$\circ$}


\chapter{Introduction}

L’objectif de ce document est de décrire le protocole de communication entre un serveur et un client pour le projet FancyCron.

Le client et le serveur communiqueront par le protocole UDP (User Datagram Protocol) définit par la RFC \href{http://tools.ietf.org/html/rfc768}{768}.

FancyCron utilisera un protocole binaire et mettra en jeu les entités suivantes réparties entre le client et le serveur :
\begin{itemize}
\item \textcolor{violet}{\texttt{FCClient-Engine}} : processus client principal
\item \textcolor{violet}{\texttt{FCClient-TaskRunner}} : processus client d'exécution des tâches
\item \textcolor{violet}{\texttt{FCServer-Engine}} : processus serveur principal
\end{itemize}
Nous détaillerons dans la suite de ce document les différentes structures de données utilisées.

\section{Convention utilisée dans ce document}

Les mots clef utilisés dans ce document seront :
« DOIT », « NE DOIT PAS », « OBLIGATOIRE », « DEVRA »,
« NE DEVRA PAS », « DEVRAIT », « NE DEVRAIT PAS », « RECOMMANDE », « PEUT », « OPTIONNEL ».

Pour plus de renseignement concernant la signification de chacun de ces mots clefs, vous pouvez consulter la RFC \href{http://www.ietf.org/rfc/rfc2119.txt}{2119}.

\vspace{20pt}
\section{Le protocle}

L'échange d'informations entre le client et le serveur \texttt{DOIT} se faire en UDP.

Nous optons pour UDP pour sa gestion simplifiée de la transmission de données, qui compense le manque d'information sur la livraison des données.

Un port (Une socket) DEVRA donc être réservé pour l’envoie et un port supplémentaire POURRA être alloué pour la réception de données.

\vspace{20pt}
\chapter{Données échangées}

Les échangées se feront via des structures de données que nous appellerons « paquets ».

Chaque paquet \texttt{DEVRA} comporter OBLIGATOIREMENT un champ « size », un champ « type », et un champ « data ». Ces champs permettront l’interprétation du paquet à l'autre bout de  la communication.
 
Les types supportés dans le protocole FancyCron sont :
\begin{itemize}
\item HELLO
\item READY
\item GETJOBLIST
\item BEGINLIST
\item REMAINLIST
\item ENDLIST
\item EMPTYLIST
\item SCHEDULED
\item DESACTIVATED
\item ACTIVATED
\item SHIFTED
\item HISTORIZED
\item OK
\item PLANIFIED
\item DECLINED
\item STARTED
\item STOPED
\item ENDEDOK
\item ENDEDWARNNING
\item ENDEDERROR
\item RUNNING
\item BYE
\end{itemize}

\vspace{20pt}
\section{Les types de paquet}

\subsection{HELLO, READY}
Le client \texttt{DOIT} envoyer un message de type \texttt{HELLO} au serveur à son démarrage.

Le serveur \texttt{DEVRA} envoyer un message de type \texttt{READY} au client, en réponse au \texttt{HELLO}, pour lui signaler qu'il est prêt et fonctionnel.

Le serveur \texttt{DEVRA} également envoyer un message de type \texttt{READY} à tous les clients, chaque fois qu'il se lance.

\subsection{GETJOBLIST}
Ce type de message \texttt{DOIT} être envoyé par le client au serveur, une fois qu'il a reçu un \texttt{READY} de ce dernier.

Ce message a pour but d'initier la demande des tâches déclarées pour le client source.

\subsection{BEGINLIST, REMAINLIST, ENDLIST}
Le serveur \texttt{DEVRAIT} associé un type \texttt{BEGINLST} au message contenant le premier élément de la liste des tâches créées pour lui.

\texttt{REMAINLIST} est le type utilisé dans les infomations des tâches restantes dans la liste.

Un message de type \texttt{ENDLIST} permet de marquer la fin des tâches de  liste. Le type \texttt{EMPTY} est envoyé pour une liste de tâches vide.

\subsection{SCHEDULED, DEACTIVATED, ACTIVATED, SHIFTED, DELATED, HISTORIZED}
Le serveur \texttt{DEVRA} envoyer un des types de messages suivants au client chaque fois qu'une tâche change de statut :
\begin{itemize}
\item \texttt{SCHEDULED} lorsqu'une tâche est nouvellement créée
\item \texttt{DESACTIVATED} lorsqu'une tâche est désactivée
\item \texttt{ACTIVATED} pour une tâche activée ou réactivée
\item \texttt{SHIFTED} pour un décalage dans le calendrier d'exécution d'une tâche
\item \texttt{DELETED} lorsqu'une tâche est supprimée de la base de données
\item \texttt{HISTORIZED} lorsqu'une tâche est mis en historique dans la base de données
\end{itemize}

\subsection{PLANIFIED, DECLINED, OK}
Le client \texttt{DEVRA} envoyer un message de type \texttt{PLANIFIED} au serveur chaque fois qu'il crée une crontab pour une tâche.

En cas d'erreur et si ta crontab n'a pas pu être créée, il \texttt{DEVRAIT} envoyer unn message de type \texttt{DECLINED} au serveur.

Après un traitement découlant d'un changement de statut envoyé du serveur, le client \texttt{DEVRA} renvoyer un message de type \texttt{OK}, contenant l'identifiant de la tâche concernée.

\subsection{STARTED, STOPPED, END*}
Du côté du client, chaque fois que l'exécution d'une tâche (commande) commence, le processus \texttt{FCClient-TaskRunner} \texttt{DEVRA} envoyer un message de type \texttt{STARTED} au processus \texttt{FCClient-Engine}.

Lorsque la tâche est suspendue, ce même processus \texttt{DOIT} envoyer un message de type \texttt{STOPPED} eu processus \texttt{FCClient-Engine}.

\texttt{FCClient-TaskRunner} \texttt{DEVRA} envoyer un message de type \texttt{ENDEDOK} à FCClient-Engine lorsque l'exécution de la tâche se termine avec succès. 

Il \texttt{DEVRA} envoyer un message de type \texttt{ENDEDWARNING} quand l'exécution se termine une erreur technique ou d'exploitation. Un message de type \texttt{ENDEDERROR} \texttt{DEVRA} être envoyé au processus \texttt{FCClient-Engine} lors que l'exécution de la tâche se termine sur une erreur due à un problème fonctionnel.

Ces messages envoyés par \texttt{FCClient-TaskRunner} à \texttt{FCClient-Engine} \texttt{DEVRAIENT} être relayés au processus \texttt{FCServer-Engine}, avec l'heure locale du poste client.

\subsection{RUNNING, BYE}
Avant d'envoyer un message au \texttt{FCClient-Engine}, le \texttt{FCClient-TaskRunner} \texttt{DEVRA} vérifier sa présence(qu'il tourne bien) par un message de type \texttt{RUNNING}.

Un message de type \texttt{BYE} \texttt{DEVRA} être envoyé au serveur lorsque le processus principal du client se termine.

\texttt{FCServer-Engine} \texttt{DEVRA} envoyer le même type de message au client lorsqu'il se termine.

\vspace{20pt}
\section{Communication inter-processus}
Le serveur FancyCron intègre un middleware mettant en place un service web de haute disponibilité. Il traite les requêtes par classe, avec des données encapsulées dans du xml. Nous allons dans cette section nous attarder sur l'historisation des informations de tâches, et sur la synchronisation entre le client (remote backend) et le serveur (middleware).

\subsection{Historisation des informations de taches}
Lorsqu'une une tâche démarre du côté du client/agent:
\begin{itemize}
\item l'exécuteur de tâches vérifie que le processus principal local (ClientEngine) en cours
\item si le processus principal est bien en service, alors l'exécuteur lui envoie l'information sur la tâche avec son état (RUNNING, puisque la tâche a démarré)
  
  Cette signalisation n'est pas bloquante et l'exécuteur retourne immédiatement attendre que la tâche se termine, pour récupérer la sortie, et toutes les autres informations sur l'exécution de la tâche. Il crée par la même occasion une entrée d'historique pour la tâche dans sa base de données locale (Il en existe une pour chaque installation du client)
\item le ClientEngine vérifie à son tour que le processus server tourne et lui transfère l'information
\item si le processus server reçoit l'information, il crée une entrée d'historique pour la tâche concernée dans la base de données centrale, avec un numéro d'ordre d'historique
\end{itemize}

Lorsque l'exécution de la tâche se termine du côté du client/agent:
\begin{itemize}
\item l'exécuteur de tâches vérifie à nouveau que le processus principal local (ClientEngine) en cours
\item si le processus principal est bien en service, alors l'exécuteur lui envoie l'information sur la tâche avec son état (\texttt{ENDED*} ou \texttt{STOPPED}, puisque la tâche a changé d'état)
\item le ClientEngine vérifie à son tour que le processus server tourne et lui transfère l'information
\item si le processus server reçoit l'information, il met à jour l'entrée d'historique précédemment créée pour la tâche concernée, et renvoie un code au ClientEngine
\item si l'état final de la tâche est un \texttt{ENDED*} (tâche terminé, quelque soit le résultat), l'historique est mis à, et le code correspondant est renvoyé au client. Dans ce cas l'entrée d'historique côté client est marquée comme historisée (HISTORIZED)
\end{itemize}

\subsection{Synchronisation des informations}
Chaque fois qu'une tâche est historisée côté client, celui-ci envoie au préalable toutes les tâches stockées en local et marquées comme non historisée, au processus principal serveur.

Et chaque fois que les infomations sur l'exécution d'une tâche sont historisées côté serveur, elle est mise à jour dans la base de données locale du client pour se prémunir des redondances, et préserver la cohérence.

\vspace{20pt}
\section{Structure des données}

La structure générale d'un paquet \texttt{DEVRA} être conforme au protocole xml-rpc, pour cette première version du logiciel
Les donnée devront être de tous les types natifs au langage python en l'occurence. La sérialisation et respectivement la désérialisation seront réalisées par l'initiateur et respectivement l'exécuteur du processus distant.
%%\begin{lstlisting}
%%  {
%%    Type;OA
%%    Contenu[TAILLE_MAX];
 %% }
%%\end{lstlisting}

  % ******************************************************************************%
\end{document}